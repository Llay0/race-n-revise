<!DOCTYPE html> 

<html>
<head>
  <title>Race 'n Revise</title>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  <link href="common.css" rel="stylesheet" type="text/css" />
</head> 

<body> 

  <div id="racer">
    <div id="hud">
      <span id="speed"            class="hud"><span id="speed_value" class="value">0</span> mph</span>
      <span id="current_lap_time" class="hud">Time: <span id="current_lap_time_value" class="value">0.0</span></span> 
      <span id="last_lap_time"    class="hud">Last Lap: <span id="last_lap_time_value" class="value">0.0</span></span>
      <span id="fast_lap_time"    class="hud">Fastest Lap: <span id="fast_lap_time_value" class="value">0.0</span></span>
      <span id="current_lane"    class="hud">Current Lane: <span id="current_lane_value" class="value">000</span></span>
    </div>

    <canvas id="canvas">
      Sorry, this example cannot be run because your browser does not support the &lt;canvas&gt; element
    </canvas>
    Loading...
  </div>

  <audio id='music'>
    <source src="music/racer.ogg">
    <source src="music/racer.mp3">
  </audio>
  <span id="mute"></span>
  <script src="common.js"></script>
  <script src="track.js"></script>
  <script>

    const FPS            = 60;                      // how many 'update' frames per second
    const STEP_LENGTH_SECS           = 1/FPS;       // how long is each frame (in seconds)
    const CANVAS_WIDTH          = 1024;             // logical canvas width
    const CANVAS_HEIGHT         = 768;              // logical canvas height
    const CENTRIFUGAL_FORCE    = 0.3;               // centrifugal force multiplier when going around curves
    const OFFROAD_DECEL   = 0.99;                   // speed multiplier when off road (e.g. you lose 2% speed each update frame)
    const SKY_SPEED       = 0.001;                  // background sky layer scroll speed when going around curve (or up hill)
    const HILL_SPEED      = 0.002;                  // background hill layer scroll speed when going around curve (or up hill)
    const TREE_SPEED      = 0.003;                  // background tree layer scroll speed when going around curve (or up hill)
    const DRAW_DISTANCE   = 300;                    // number of segments to draw
    const SEGMENT_LENGTH  = 200;                    // length of a single segment
    const RUMBLE_LENGTH   = 3;                      // number of segments per red/white rumble strip
    const FIELD_OF_VIEW_ANGLE    = 100;             // angle (degrees) for field of view
    const CAMERA_HEIGHT   = 1000;                    // z height of camera
    const CAMERA_DEPTH  = 1 / Math.tan((FIELD_OF_VIEW_ANGLE/2) * Math.PI/180);
    const PLAYER_Z  = (CAMERA_HEIGHT * CAMERA_DEPTH);  // player relative z distance from camera (computed)
    const RESOLUTION = CANVAS_HEIGHT/480;  // scaling factor to provide resolution independence (computed)
    const ROAD_WIDTH = 1500;                    // actually half the roads width, easier math if the road spans from -roadWidth to +roadWidth
    const NUM_LANES  = 4;                       // number of lanes
    const FOG_DENSITY = 5;                       // exponential fog density
    
    const MAX_SPEED       = SEGMENT_LENGTH/STEP_LENGTH_SECS;      // top speed (ensure we can't move more than 1 segment in a single frame to make collision detection easier)
    const ACCEL_RATE          =  MAX_SPEED/5;             // acceleration rate - tuned until it 'felt' right
    const BRAKE_RATE       = -MAX_SPEED;               // deceleration rate when braking
    const DECELERATION          = -MAX_SPEED/5;             // 'natural' deceleration rate when neither accelerating, nor braking
    const OFF_ROAD_DECEL   = -MAX_SPEED/2;             // off road deceleration is somewhere in between
    const OFF_ROAD_LIMIT   =  MAX_SPEED/4;             // limit when off road deceleration no longer applies (e.g. you can always go at least this speed even when off road)

    let skyOffset      = 0;                       // current sky scroll offset
    let hillOffset     = 0;                       // current hill scroll offset
    let treeOffset     = 0;                       // current tree scroll offset
        
    let segments       = [];                      // array of road segments
    let trackLength    = null;                    // z length of entire track (computed)

    const canvas         = Dom.get('canvas');     // our canvas...
    canvas.width  = CANVAS_WIDTH;                 // set programmatic width
    canvas.height = CANVAS_HEIGHT;                // set programmetic height
    const ctx = canvas.getContext('2d');          // 2d drawing context
    
    var background     = null;                    // our background image (loaded below)
    var sprites        = null;                    // our spritesheet (loaded below)
    
    let playerX        = 0;                       // player x offset from center of road (-1 to 1 to stay independent of roadWidth)
    let position       = 0;                       // current camera Z position (add playerZ to get player's absolute Z position)
    let currentSpeed          = 0;                       // current speed
        
    
    let currentLapTime = 0;                       // current lap time
    let lastLapTime    = null;                    // last lap time

    let keyLeftPressed        = false;
    let keyRightPressed       = false;
    let keyFasterPressed      = false;
    let ketSlowerPressed      = false;

    const hud = {
      speed:            { value: null, dom: Dom.get('speed_value')            },
      current_lap_time: { value: null, dom: Dom.get('current_lap_time_value') },
      last_lap_time:    { value: null, dom: Dom.get('last_lap_time_value')    },
      fast_lap_time:    { value: null, dom: Dom.get('fast_lap_time_value')    },
      current_lane:    { value: null, dom: Dom.get('current_lane_value')    }
    }

    //=========================================================================
    // Updates all game elements
    //=========================================================================

    function update(dt) {

      var playerSegment = findSegment(position+PLAYER_Z);
      var playerW       = SPRITES.PLAYER_STRAIGHT.w * SPRITES.SCALE;
      var speedPercent  = currentSpeed/MAX_SPEED;
      var dx            = dt * 2 * speedPercent; // at top speed, should be able to cross from left to right (-1 to 1) in 1 second
      var startPosition = position;

      position = Util.increase(position, dt * currentSpeed, trackLength);

      if (keyLeftPressed)
        playerX = playerX - dx;
      else if (keyRightPressed)
        playerX = playerX + dx;

      playerX = playerX - (dx * speedPercent * playerSegment.curve * CENTRIFUGAL_FORCE);

      if (keyFasterPressed)
        currentSpeed = Util.accelerate(currentSpeed, ACCEL_RATE, dt);
      else if (ketSlowerPressed)
        currentSpeed = Util.accelerate(currentSpeed, BRAKE_RATE, dt);
      else
        currentSpeed = Util.accelerate(currentSpeed, DECELERATION, dt);


      if ((playerX < -1) || (playerX > 1)) {

        if (currentSpeed > OFF_ROAD_LIMIT)
          currentSpeed = Util.accelerate(currentSpeed, OFFROAD_DECEL, dt);

        for(let n = 0 ; n < playerSegment.sprites.length ; n++) {
          const sprite  = playerSegment.sprites[n];
          const spriteW = sprite.source.w * SPRITES.SCALE;
          if (Util.overlap(playerX, playerW, sprite.offset + spriteW/2 * (sprite.offset > 0 ? 1 : -1), spriteW)) {
            currentSpeed = MAX_SPEED/5;
            position = Util.increase(playerSegment.p1.world.z, -PLAYER_Z, trackLength); // stop in front of sprite (at front of segment)
            break;
          }
        }
      }

      playerX = Util.limit(playerX, -3, 3);     // dont ever let it go too far out of bounds
      currentSpeed   = Util.limit(currentSpeed, 0, MAX_SPEED); // or exceed maxSpeed

      // Move the sky, hills, trees relative to the current player segment
      skyOffset  = Util.increase(skyOffset,  SKY_SPEED  * playerSegment.curve * (position-startPosition)/SEGMENT_LENGTH, 1);
      hillOffset = Util.increase(hillOffset, HILL_SPEED * playerSegment.curve * (position-startPosition)/SEGMENT_LENGTH, 1);
      treeOffset = Util.increase(treeOffset, TREE_SPEED * playerSegment.curve * (position-startPosition)/SEGMENT_LENGTH, 1);

      if (position > PLAYER_Z) {
        if (currentLapTime && (startPosition < PLAYER_Z)) {
          lastLapTime    = currentLapTime;
          currentLapTime = 0;
          if (lastLapTime <= Util.toFloat(Dom.storage.fast_lap_time)) {
            Dom.storage.fast_lap_time = lastLapTime;
            updateHud('fast_lap_time', formatTime(lastLapTime));
            Dom.addClassName('fast_lap_time', 'fastest');
            Dom.addClassName('last_lap_time', 'fastest');
          }
          else {
            Dom.removeClassName('fast_lap_time', 'fastest');
            Dom.removeClassName('last_lap_time', 'fastest');
          }
          updateHud('last_lap_time', formatTime(lastLapTime));
          Dom.show('last_lap_time');
        }
        else {
          currentLapTime += dt;
        }
      }

      updateHud('speed',            5 * Math.round(currentSpeed/500));
      updateHud('current_lap_time', formatTime(currentLapTime));
      
      const lane_index = playerX < -0.5 ? 0 : playerX < 0 ? 1 : playerX < 0.5 ? 2 : 3;
      updateHud('current_lane', lane_index);
    }

    function updateHud(key, value) { // accessing DOM can be slow, so only do it if value has changed
      if (hud[key].value !== value) {
        hud[key].value = value;
        Dom.set(hud[key].dom, value);
      }
    }

    function formatTime(dt) {
      var minutes = Math.floor(dt/60);
      var seconds = Math.floor(dt - (minutes * 60));
      var tenths  = Math.floor(10 * (dt - Math.floor(dt)));
      if (minutes > 0)
        return minutes + "." + (seconds < 10 ? "0" : "") + seconds + "." + tenths;
      else
        return seconds + "." + tenths;
    }

    //=========================================================================
    // Renders the game elements
    //=========================================================================

    function render() {

      const baseSegment   = findSegment(position);
      const basePercent   = Util.percentRemaining(position, SEGMENT_LENGTH);
      const playerSegment = findSegment(position+PLAYER_Z);
      const playerPercent = Util.percentRemaining(position+PLAYER_Z, SEGMENT_LENGTH);
      const playerY       = Util.interpolate(playerSegment.p1.world.y, playerSegment.p2.world.y, playerPercent);
      let maxy          = CANVAS_HEIGHT;

      var x  = 0;
      var dx = - (baseSegment.curve * basePercent);

      ctx.clearRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);

      Render.background(ctx, background, CANVAS_WIDTH, CANVAS_HEIGHT, BACKGROUND.SKY,   skyOffset,  RESOLUTION * SKY_SPEED  * playerY);
      Render.background(ctx, background, CANVAS_WIDTH, CANVAS_HEIGHT, BACKGROUND.HILLS, hillOffset, RESOLUTION * HILL_SPEED * playerY);
      Render.background(ctx, background, CANVAS_WIDTH, CANVAS_HEIGHT, BACKGROUND.TREES, treeOffset, RESOLUTION * TREE_SPEED * playerY);

      for(let n = 0 ; n < DRAW_DISTANCE ; n++) {

        const segment  = segments[(baseSegment.index + n) % segments.length];
        segment.looped = segment.index < baseSegment.index;
        segment.fog    = Util.exponentialFog(n/DRAW_DISTANCE, FOG_DENSITY);
        segment.clip   = maxy;

        Util.project(segment.p1, (playerX * ROAD_WIDTH) - x,      playerY + CAMERA_HEIGHT, position - (segment.looped ? trackLength : 0), CAMERA_DEPTH, CANVAS_WIDTH, CANVAS_HEIGHT, ROAD_WIDTH);
        Util.project(segment.p2, (playerX * ROAD_WIDTH) - x - dx, playerY + CAMERA_HEIGHT, position - (segment.looped ? trackLength : 0), CAMERA_DEPTH, CANVAS_WIDTH, CANVAS_HEIGHT, ROAD_WIDTH);

        x  = x + dx;
        dx = dx + segment.curve;

        if ((segment.p1.camera.z <= CAMERA_DEPTH)         || // behind us
            (segment.p2.screen.y >= segment.p1.screen.y) || // back face cull
            (segment.p2.screen.y >= maxy))                  // clip by (already rendered) hill
          continue;

        Render.segment(ctx, CANVAS_WIDTH, NUM_LANES,
                       segment.p1.screen.x,
                       segment.p1.screen.y,
                       segment.p1.screen.w,
                       segment.p2.screen.x,
                       segment.p2.screen.y,
                       segment.p2.screen.w,
                       segment.fog,
                       segment.color);

        maxy = segment.p1.screen.y;
      }

      for(let n = (DRAW_DISTANCE-1) ; n > 0 ; n--) {
        segment = segments[(baseSegment.index + n) % segments.length];

        for(let i = 0 ; i < segment.sprites.length ; i++) {
          const sprite      = segment.sprites[i];
          const spriteScale = segment.p1.screen.scale;
          const spriteX     = segment.p1.screen.x + (spriteScale * sprite.offset * ROAD_WIDTH * CANVAS_WIDTH/2);
          const spriteY     = segment.p1.screen.y;
          Render.sprite(ctx, CANVAS_WIDTH, CANVAS_HEIGHT, RESOLUTION, ROAD_WIDTH, sprites, sprite.source, spriteScale, spriteX, spriteY, (sprite.offset < 0 ? -1 : 0), -1, segment.clip);
        }

        if (segment == playerSegment) {
          Render.player(ctx, CANVAS_WIDTH, CANVAS_HEIGHT, RESOLUTION, ROAD_WIDTH, sprites, currentSpeed/MAX_SPEED,
                        CAMERA_DEPTH/PLAYER_Z,
                        CANVAS_WIDTH/2,
                        (CANVAS_HEIGHT/2) - (CAMERA_DEPTH/PLAYER_Z * Util.interpolate(playerSegment.p1.camera.y, playerSegment.p2.camera.y, playerPercent) * CANVAS_HEIGHT/2),
                        currentSpeed * (keyLeftPressed ? -1 : keyRightPressed ? 1 : 0),
                        playerSegment.p2.world.y - playerSegment.p1.world.y);
        }
      }
    }

    function findSegment(z) {
      return segments[Math.floor(z/SEGMENT_LENGTH) % segments.length]; 
    }

   
    function resetSprites() {
      var n, i;

      addSprite(20,  SPRITES.BILLBOARD07, -1);
      addSprite(40,  SPRITES.BILLBOARD06, -1);
      addSprite(60,  SPRITES.BILLBOARD08, -1);
      addSprite(80,  SPRITES.BILLBOARD09, -1);
      addSprite(100, SPRITES.BILLBOARD01, -1);
      addSprite(120, SPRITES.BILLBOARD02, -1);
      addSprite(140, SPRITES.BILLBOARD03, -1);
      addSprite(160, SPRITES.BILLBOARD04, -1);
      addSprite(180, SPRITES.BILLBOARD05, -1);

      addSprite(240,                  SPRITES.BILLBOARD07, -1.2);
      addSprite(240,                  SPRITES.BILLBOARD06,  1.2);
      addSprite(segments.length - 25, SPRITES.BILLBOARD07, -1.2);
      addSprite(segments.length - 25, SPRITES.BILLBOARD06,  1.2);

      for(n = 10 ; n < 200 ; n += 4 + Math.floor(n/100)) {
        addSprite(n, SPRITES.PALM_TREE, 0.5 + Math.random()*0.5);
        addSprite(n, SPRITES.PALM_TREE,   1 + Math.random()*2);
      }

      for(n = 250 ; n < 1000 ; n += 5) {
        addSprite(n,     SPRITES.COLUMN, 1.1);
        addSprite(n + Util.randomInt(0,5), SPRITES.TREE1, -1 - (Math.random() * 2));
        addSprite(n + Util.randomInt(0,5), SPRITES.TREE2, -1 - (Math.random() * 2));
      }

      for(n = 200 ; n < segments.length ; n += 3) {
        addSprite(n, Util.randomChoice(SPRITES.PLANTS), Util.randomChoice([1,-1]) * (2 + Math.random() * 5));
      }

      var side, sprite, offset;
      for(n = 1000 ; n < (segments.length-50) ; n += 100) {
        side      = Util.randomChoice([1, -1]);
        addSprite(n + Util.randomInt(0, 50), Util.randomChoice(SPRITES.BILLBOARDS), -side);
        for(i = 0 ; i < 20 ; i++) {
          sprite = Util.randomChoice(SPRITES.PLANTS);
          offset = side * (1.5 + Math.random());
          addSprite(n + Util.randomInt(0, 50), sprite, offset);
        }
          
      }

    }
    //=========================================================================
    // THE GAME LOOP
    //=========================================================================

    const options = {
      canvas: canvas, render: render, update: update, step: STEP_LENGTH_SECS,
      images: ["background", "sprites"],
      keys: [
        { keys: [KEY.LEFT,  KEY.A], mode: 'down', action: function() { keyLeftPressed   = true;  } },
        { keys: [KEY.RIGHT, KEY.D], mode: 'down', action: function() { keyRightPressed  = true;  } },
        { keys: [KEY.UP,    KEY.W], mode: 'down', action: function() { keyFasterPressed = true;  } },
        { keys: [KEY.DOWN,  KEY.S], mode: 'down', action: function() { ketSlowerPressed = true;  } },
        { keys: [KEY.LEFT,  KEY.A], mode: 'up',   action: function() { keyLeftPressed   = false; } },
        { keys: [KEY.RIGHT, KEY.D], mode: 'up',   action: function() { keyRightPressed  = false; } },
        { keys: [KEY.UP,    KEY.W], mode: 'up',   action: function() { keyFasterPressed = false; } },
        { keys: [KEY.DOWN,  KEY.S], mode: 'up',   action: function() { ketSlowerPressed = false; } }
      ],
      ready: function(images) {
        background = images[0];
        sprites    = images[1];
        segments = Track.getTrackSegments(PLAYER_Z);
        trackLength = Track.trackLength;
        Dom.storage.fast_lap_time = Dom.storage.fast_lap_time || 180;
        updateHud('fast_lap_time', formatTime(Util.toFloat(Dom.storage.fast_lap_time)));
      }
    }
  
    Game.run(options);

  </script>

</body> 
</html>
